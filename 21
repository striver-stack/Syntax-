#include <bits/stdc++.h>
using namespace std;


int n,m,L,k;
int id[55][55], vs[55][55];
bool vw[56][55], hw[55][56];

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>n>>m;
    cin>>L;

    for(int i=0;i<=n;i++) for(int j=0;j<m;j++) vw[i][j]=0;
    for(int i=0;i<n;i++) for(int j=0;j<=m;j++) hw[i][j]=0;
    for(int i=0;i<n;i++) for(int j=0;j<m;j++) id[i][j]=-1, vs[i][j]=0;

    for(int t=0;t<L;t++){
        int x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;
        if(x1==x2){
            int a=min(y1,y2), b=max(y1,y2);
            if(x1<0) x1=0; if(x1>n) x1=n;
            if(a<0) a=0; if(b>m) b=m;
            for(int y=a;y<b;y++) if(x1>=0 && x1<=n && y>=0 && y<m) vw[x1][y]=1;
        }else if(y1==y2){
            int a=min(x1,x2), b=max(x1,x2);
            if(y1<0) y1=0; if(y1>m) y1=m;
            if(a<0) a=0; if(b>n) b=n;
            for(int x=a;x<b;x++) if(y1>=0 && y1<=m && x>=0 && x<n) hw[x][y1]=1;
        }
    }

    cin>>k;

    auto Lm=&{ return x>0 && !vw[x][y]; };
    auto Rm=&{ return x<n-1 && !vw[x+1][y]; };
    auto Dm=&{ return y>0 && !hw[x][y]; };
    auto Um=&{ return y<m-1 && !hw[x][y+1]; };

    int c=0;
    for(int x=0;x<n;x++){
        for(int y=0;y<m;y++){
            if(vs[x][y]) continue;
            queue<pair<int,int>> q;
            q.push({x,y}); vs[x][y]=1; id[x][y]=c;
            while(!q.empty()){
                auto p=q.front(); q.pop();
                int i=p.first, j=p.second;
                if(Lm(i,j) && !vs[i-1][j]){ vs[i-1][j]=1; id[i-1][j]=c; q.push({i-1,j}); }
                if(Rm(i,j) && !vs[i+1][j]){ vs[i+1][j]=1; id[i+1][j]=c; q.push({i+1,j}); }
                if(Dm(i,j) && !vs[i][j-1]){ vs[i][j-1]=1; id[i][j-1]=c; q.push({i,j-1}); }
                if(Um(i,j) && !vs[i][j+1]){ vs[i][j+1]=1; id[i][j+1]=c; q.push({i,j+1}); }
            }
            c++;
        }
    }

    if(k<1 || k>c){ cout<<"Impossible"; return 0; }

    int ans = INT_MAX;

    for(int y0=0;y0<m;y0++){
        for(int y1=y0+1;y1<=m;y1++){
            int h = y1 - y0;
            vector<int> cnt(c,0);
            int u=0, Lx=0;
            for(int Rx=0;Rx<n;Rx++){
                for(int y=y0;y<y1;y++){
                    int g=id[Rx][y];
                    if(++cnt[g]==1) u++;
                }
                while(Lx<=Rx && u>=k){
                    if(u==k){
                        int w = Rx - Lx + 1;
                        int ar = w * h;
                        if(ar < ans) ans = ar;
                    }
                    for(int y=y0;y<y1;y++){
                        int g=id[Lx][y];
                        if(--cnt[g]==0) u--;
                    }
                    Lx++;
                }
            }
        }
    }

    if(ans==INT_MAX) cout<<"Impossible";
    else cout<<ans;
    return 0;
}



// at hidden test case getting wrong answers and compiler 
// please make sure clear them and give me correct code 

/*Gift BoxesMarks: 100
Problem Description
Nimo loves geometry and is tackling a challenge with a grid of rectangular boxes, trying to solve something unique. Let's take a closer look at it.

Given an N × M grid of rectangular gift boxes, partition lines define the boundaries between individual boxes. The task is to place an axis-aligned rectangular block on the grid such that it overlaps exactly K gift boxes, either partially or fully.

The objective is to determine the minimum possible area of such a rectangular block. If it is not possible to cover exactly K boxes, the output should be "Impossible."

Constraints
1 <= N, M <= 50

1 <= L <= 30

0 <= x1, y1, x2, y2 <= 50

1 <= K <= 500

All sections are guaranteed to be rectangles or squares.

Input
The first line contains two space-separated integers N and M, representing the grid dimensions.

The second line contains an integer L, denoting the number of partition lines.

The next L lines each contain four space-separated integers x1, y1, x2, y2, specifying the endpoints of a partition line segment.

The final line contains an integer K, representing the number of gift boxes to be covered.

Output
Output a single integer representing the minimum area of the rectangular block that covers exactly K gift boxes.

If it is not possible to cover exactly K boxes, or if K exceeds the total number of boxes, output "Impossible."

Time Limit (secs)
1

Examples
Example 1

Input

5 4

6

1 0 1 2

0 3 3 3

2 0 2 4

4 0 4 2

3 3 5 3

0 2 5 2

8

Output

15

Explanation

The arrangement of gift boxes given in the above input is shown below.

com.tcs.cv.automata.ei.middleware.DocxToHtmlConverter@6c000e0c:image1.png

Fig.1

A rectangular block of size 5 × 3, placed with its top-left corner at (0, 4), overlaps exactly 8 gift boxes. The resulting area is 15, which is the minimum possible.

Example 2

Input

3 3

4

0 1 3 1

1 0 1 3

0 2 3 2

2 0 2 3

5

Output

Impossible

Explanation

The arrangement of gift boxes given in the above input is shown below.

com.tcs.cv.automata.ei.middleware.DocxToHtmlConverter@6c000e0c:image2.png

Fig.2

No rectangular block can overlap exactly 5 gift boxes, either partially or fully. Therefore, the correct output is "Impossible."*/
