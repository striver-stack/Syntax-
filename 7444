// 7

#include <bits/stdc++.h>
using namespace std;

int R, C, N;
vector<vector<pair<int,int>>> threat;

vector<vector<long long>> threatMask;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> R >> C;
    cin >> N;

    int total = R * C;

    threat.resize(N);

    for (int i = 0; i < N; i++) {
        int k;
        cin >> k;
        while (k--) {
            int dr, dc;
            cin >> dr >> dc;
            threat[i].push_back({dr, dc});
        }
    }

    threatMask.assign(N, vector<long long>(total, 0));

    for (int i = 0; i < N; i++) {
        for (int cell = 0; cell < total; cell++) {

            int r = cell / C;
            int c = cell % C;

            long long mask = 0;

            for (auto &t : threat[i]) {
                int nr = r + t.first;
                int nc = c + t.second;

                if (nr < 0 || nr >= R || nc < 0 || nc >= C)
                    continue;

                int ncell = nr * C + nc;
                mask |= (1LL << ncell);
            }

            threatMask[i][cell] = mask;
        }
    }

    int ans = 0;

    for (int subset = 0; subset < (1 << N); subset++) {

        int cnt = __builtin_popcount(subset);
        if (cnt <= ans) continue;

        vector<int> travellers;
        for (int i = 0; i < N; i++)
            if (subset & (1 << i))
                travellers.push_back(i);

        function<bool(int, long long, long long)> place =
        [&](int idx, long long occupied, long long threatened) {

            if (idx == travellers.size())
                return true;

            int t = travellers[idx];

            for (int cell = 0; cell < total; cell++) {

                if (occupied & (1LL << cell)) continue;
                if (threatened & (1LL << cell)) continue;

                long long newThreat = threatMask[t][cell];

                if (newThreat & occupied) continue;

                if (place(idx + 1,
                          occupied | (1LL << cell),
                          threatened | newThreat))
                    return true;
            }

            return false;
        };

        if (place(0, 0, 0))
            ans = cnt;
    }

    cout << ans << "\n";
    return 0;
}

// input1:
// 2 4
// 8
// 4
// 0 1
// 1 0
// -1 0
// 0 -1
// 1
// 0 1
// 1
// 1 0
// 2
// 0 -1
// -1 0
// 0
// 0
// 3
// -2 0
// 2 2
// 1 0
// 4
// 0 1
// 1 0
// -1 0
// 0 -1
// your output1:
// 6
// correct output1:
// 6



// input2;
// 3 3
// 7
// 2
// 0 1
// 1 0
// 4
// -1 0
// 0 -1
// 0 1
// 1 0
// 4
// -1 0
// 0 -1
// 0 1
// 1 0
// 4
// -1 0
// 0 -1
// 0 1
// 1 0
// 4
// -1 0
// 0 -1
// 0 1
// 1 0
// 0
// 0
// your output2:
// 5
// correct output2:
// 5

/*Grumpy TravelersMarks: 100
Problem Description
A hotel manager is tasked with assigning unique travelers to a finite arrangement of rooms. Each traveler possesses a defined Grumpiness Profile, which includes specific threat coordinates (dr, dc), indicating the particular rooms that become unavailable when that individual is assigned.

The grid has dimensions R x C, and the goal is to position maximum number of travelers without violating any threat constraints.

When traveler Ti is positioned at cell (r1, c1), the traveler imposes threat constraints on the cell located at (r1 + dr, c1 + dc), where each (dr, dc) pair is defined in the traveler's threat profile. A placement is considered valid only if the following conditions are satisfied:

No traveler is placed in a cell threatened by another traveler already on the grid.
No traveler is assigned to a cell that would, in turn, threaten the position of any traveler already placed on the grid.
Each traveler is distinct and may be used at most once.
Determine the maximum number of travelers that can be simultaneously placed on the grid without violating any defined threat constraints.

Note: Travelers do not know the grid size in advance. Their threat rules may point to coordinates that fall outside the boundaries of the R x C grid. Any such "out-of-bound" threats are simply ignored and do not affect the placement.

Constraints
1 <= R + C <= 7

1 <= N <= 15

Input
First line consists of two integers, R and C representing the size of the grid.

Second line consists of an integer N denoting the total number of unique travelers.

Next lines - For each traveler T1 to TN,

An integer K (The number of threat rules for this traveler).
K lines each containing two integers dr and dc.
dr and dc can be negative too.

Output
Print a single integer representing the maximum number of travelers that can be successfully placed.

Time Limit (secs)
1

Examples
Example 1

Input

2 4

8

4

0 1

1 0

-1 0

0 -1

1

0 1

1

1 0

2

0 -1

-1 0

0

0

3

-2 0

2 2

1 0

4

0 1

1 0

-1 0

0 -1

Output

6

Explanation

The room layout is a 2×4 grid, giving a total of 8 rooms, and there are 8 travelers. However, with the given constraints, the maximum number of travelers that can be accommodated is 6, which is shown below.

T1 . T4 T2

. T3 T5 T6

*The arrangement shown above is one valid configuration that achieves this maximum value.

Example 2

Input

3 3

7

2

0 1

1 0

4

-1 0

0 -1

0 1

1 0

4

-1 0

0 -1

0 1

1 0

4

-1 0

0 -1

0 1

1 0

4

-1 0

0 -1

0 1

1 0

0

0

Output

5

Explanation

The room layout is a 3×3 grid, giving a total of 9 rooms, and there are 7 travelers. However, with the given constraints, the maximum number of travelers that can be accommodated is 5, which is shown below.

T1 . T2

. T3 .

T4 . T5

*The arrangement shown above is one valid configuration that achieves this maximum value.*/

// but some of private testcases are faild find the gaps and edges and fill them
// consider some tofe and conner private testcases and check if they passing or not
// please make sure you give correct answer
